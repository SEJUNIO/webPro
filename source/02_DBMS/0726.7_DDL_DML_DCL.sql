[VII] DDL, DML, DCL
-- SQL = DDL (테이블 생성, 테이블 삭제, 테이블 구조변경, 테이블의 모든 데이터 제거)
-- SQL = DML (SELECT, INSERT, UPDATE, DELETE)
-- SQL = DCL (사용자계정 생성, 사용자에게 권한부여, 권한박탈, 사용자계정 삭제, 트랜젝션명령어)

-- ★ ★ ★ DDL ★ ★ ★

-- 1. 테이블 생성(CREATE TABLE 테이블명 ....) : 테이블 구조를 정의
CREATE TABLE BOOK (
  BOOKID   NUMBER(4), -- BOOKID 필트의 타입은 숫자4자리
  BOOKNAME VARCHAR2(20), -- BOOKNAME 필드의 타입은 문자 20BYTE
  PUBLISHER VARCHAR2(20), -- PUBLISHER 필드의 타입은 문자 20BYTE
  RDATE     DATE,         -- RDATE 필드의 타입은 DATE
  PRICE     NUMBER(7,2),   -- PRICE필드의 타입은 숫자 전체 7자리. 소수점이하는 2자리, 소수점앞 5자리
  PRIMARY KEY(BOOKID)     -- 제약조건 : BOOKID필드가 PRIMARY KEY(주키) : UNIQUE, NOT NULL
);
SELECT * FROM BOOK;

CREATE TABLE BOOK(
    BOOKID NUMBER(4), PRIMARY KEY,
    BOOKNAME VARCHAR2(20), -- BOOKNAME 필드의 타입은 문자 20 BYTE
    PUBLISHER VARCHAR2(20), -- PUBLISHER 필드의 타입은 문자 20 BYTE
    ROATE      DATE,        -- ROATE 필드의 타입은 DATE
    PRICE       NUMBER(7,2)      --PRICE 필드의 타입은 숫자 전체 7자리, 소수점이하는 2자리, 소수점앞 5자리
);

-- DEPT01 : DEPTNO(수2:PK), DANME(문자14), LOC(문자13)
CREATE TABLE DEPT01(
    DEPTNO NUMBER (2) PRIMARY KEY,
    DNAME VARCHAR2(14),
    LOC VARCHAR2(13)
);
-- EMP01 : EMPNO(숫4:PK주키), ENAME(문자10), SAL(숫7,2), DEPTNO(숫2:FK외래키)
CREATE TABLE EMP01 (
    EMPNO NUMBER(4) PRIMARY KEY,
    ENAME VARCHAR2(10),
    SAL NUMBER(7,2),
    DEPTNO NUMBER(2) REFERENCES DEPT01 (DEPTNO)
);
SELECT * FROM EMP01;

--------------------------------------------------------------------------------------------------------------
-- 서브쿼리를 이용한 테이블 생성
CREATE TABLE EMP02
    AS
    SELECT * FROM EMP; -- 서브쿼리 결과로 EMP02 테이블 생성후 데이터로 들어감(제약조건 미포함)
    
SELECT * FROM EMP02;

--------------------------------------------------------------------------------------------------------------
-- EMP03 -- EMP의 특정 필드
CREATE TABLE EMP03
    AS
    SELECT EMPNO, ENAME, DEPTNO FROM EMP; -- EMP테이블의 EMPNO, ENAME, DEPTNO만 추출한 데이터가 EMP03 
    
SELECT * FROM EMP03;

--------------------------------------------------------------------------------------------------------------
-- EMP04. -- EMP의 특정 행
CREATE TABLE EMP04
    AS
    SELECT * FROM EMP WHERE DEPTNO = 10; -- EMP에서 10번 부서의 데이터만 추출해서 EMP04
SELECT * FROM EMP04;

--------------------------------------------------------------------------------------------------------------
-- EMP05 -- EMP의 구조만 추출(데이터 추출하지 않음)
CREDATE TABLE EMP05
    AS
    SELECT * FROM EMP WHERE 1=0;
SELECT * FROM EMP05;
SELECT ROWNUM, EMPNO, ENAME FROM EMP; -- ROWNUM : 테이블에서 행의 읽어들인 순서

--------------------------------------------------------------------------------------------------------------

-- 2. 테이블 구조변경 ( ALTER TABLE 테이블명 ADD || MODIFY || DROP ~)
    -- (1) 필드추가(ADD)
SELECT * FROM EMP03; -- EMPNO(숫자 4) ,ENAME(문자 10) ,DEPTNO(숫자 2)
ALTER TABLE EMP03 ADD ( JOB VARCHAR2(20), SAL NUMBER(7) );
SELECT * FROM EMP03; -- 추가된 필드는 NULL 데이터로 채워짐
    -- (2) 필드수정(MODIFY)
ALTER TABLE EMP03 MODIFY (EMPNO VARCHAR02(4)); -- 숫자 데이터가 들어있어 숫자로만 변경가능(숫자보다 큰 사이즈로만)
ALTER TABLE EMP03 MODIFY (EMPNO NUMBER(5));
ALTER TABLE EMP03 MODIFY (JOB NUMBER(5)); -- NULL 필드는 마음대로 수정 가능
SELECT MAX(LENGTH(ENAME)) FROM EMP03; -- EMP03의 ENAME은 6글자가 최장길이
ALTER TABLE EMP03 MODIFY (ENAME VARCHAR2(6)); -- 문자데이터를 늘리거나 줄이는데는 기존 데이터에 따라 가능
    -- (3) 필드 삭제 ( DROP)
ALTER TABLE EMP03 DROP COLUMN JOB; -- JOB 필드 삭제
SELECT * FROM EMP03;

-- 3. 테이블 삭제 (DROP TABLE 테이블명)
DROP TABLE EMP01;
DROP TABLE DEPT; -- EMP테이블에서 DEPT의 DEPTNO을 참조하는 경우 EMP테이블을 삭제한 후 DEPT를 삭제

-- 4. 테이블의 모든 행을 제거 
SELECT * FROM EMP03;
TRUNCATE TABLE EMP03; -- ROLLBACK 불가
SELECT * FROM EMP03;

-- 5. 테이블명변경 ( RENAME 테이블명 TO 바꿀테이블명)
SELECT * FROM EMP02;
RENAME EMP02 TO EMP2;
SELECT * FROM EMP2;

-- 6. 데이터 딕셔너리(데이터베이스 자원을 효율적으로 관리하기 위한 시스템 테이블 : 접근 불가)
--       VS
--  데이터 딕셔너리 뷰 (접근가능)의 종류
-- (1) USER_XXX : 현계정에서 소유하고 있는 객체(테이블, 제약조건, 뷰, 인덱스)
SELECT * FROM USER_TABLES;
SELECT * FROM USER_CONSTRAINTS;
SELECT * FROM USER_VIEWS;
SELECT * FROM USER_INDEXES;
-- (2) ALL_XXX : 현 계정에서 접근가능한 객체(테이블, 제약조건, 뷰, 인덱스)
SELECT * FROM ALL_TABLES;
SELECT * FROM ALL_CONSTRAINTS;
SELECT * FROM ALL_VIEWS;
SELECT * FROM ALL_INDEXES;
-- (3) DBA_XXX : DBA권한에서만 접근 가능 DEMS의 모든 객체(테이블, 제약조건, 뷰, 인덱스)
SELECT * FROM DBA_TABLES;
SELECT * FROM DBA_CONSTRAINTS;
SELECT * FROM DBA_VIEWS;
SELECT * FROM DBA_INDEXES;

-- ★ ★ ★ DML ★ ★ ★
-- (1). INSERT INTO 테이블명 VALUES (값1, 갑2, ...);
    -- INSERT INTO 테이블명 (필드1, 필드2, ..)VALUES (값1, 값2, ...);
SELECT *FROM DEPT01;
INSERT INTO DEPT01 VALUES(50, 'ACCOUNTING', 'SEOUL');
INSERT INTO DEPT01 VALUES(60, 'SALES', NULL); -- 명시적으로 NULL 추가
INSERT INTO DEPT01 (DEPTNO, LOC, DNAME) VALUES (70, '서대문', 'RESEARCH');
INSERT INTO DEPT01 (DEPTNO, DNAME) VALUES(80, 'IT'); -- 묵시적으로 NULL추가 (명시되지 않은 필드값은 NULL)
COMMIT;   -- 오라클에 영구적으로 적용하는 명령어(트랜직션 명령어 ) : DML명령어만 적용 : 데이터 처리를 위한 한 단위.

-- 서브쿼리를 이용한 INSERT
    -- DEPT테이블의 10~30 부서를 DEPT01로 INSERT
INSERT INTO DEPT01 SELECT * FROM DEPT WHERE DEPTNO BETWEEN 10 AND 30;

-- ★ 연습문제 ★
DROP TABLE SAM01;
CREATE TABLE SAM01(
  EMPNO  NUMBER(4) PRIMARY KEY,
  ENAME VARCHAR2(10),
  JOB   VARCHAR2(9),
  SAL     NUMBER(7,2)     
);
INSERT INTO SAM01 VALUES(1000, 'APPLE', 'POLICE',10000);
INSERT INTO SAM01 VALUES(1010, 'BANANA', 'NURSE', 15000);
INSERT INTO SAM01 VALUES(1020, 'ORANGE', 'DOCTOR',25000);
INSERT INTO SAM01 (EMPNO, ENAME,SAL) VALUES(1030, 'VERY', 25000); -- 묵시적 NULL 추가
-- INSERT INTO SAM01 VALUES(1030, 'VERY', NULL, 25000);
INSERT INTO SAM01 (EMPNO, ENAME,SAL) VALUES(1040, 'CAT', 2000);
INSERT INTO SAM01 SELECT EMPNO, ENAME, JOB, SAL FROM EMP WHERE DEPTNO =10;
SELECT * FROM SAM01;
COMMIT;

-- 2. UPDATE 테이블 SET 필드명1=값1, 필드명2=값2,...(WHERE 조건) :
DROP TABLE EMP01;
SELECT * FROM EMP01;
CREATE TABLE EMP01 AS SELECT EMPNO, ENAME, SAL, HIREDATE, DEPTNO FROM EMP;
    --EX. 부서번호를 30으로 수정
    UPDATE EMP01 SET DEPTNO=30;
    ROLLBACK;
    -- 모든 직원(EMP01)의 급여(SAL)을 10% 인상
    UPDATE EMP01 SET SAL = SAL*1.1;
    -- EX. EMP01 : 10번 부서 직원의 입사일을 오늘, 부서번호는 30번으로 수정
    UPDATE EMP01
        SET HIREDATE = SYSDATE,
            DEPTNO = 30 
            WHERE DEPTNO = 10;
    -- EX3. 급여가 3000이상인 사원만 급여를 10%인상
    UPDATE EMP01
        SET SAL = SAL*1.1
        WHERE SAL >=3000;
    -- EX4. 근무지가 'DALLAS'인 직원의 급여를 1000$ 인상
    UPDATE EMP01 SET SAL = SAL+1000
        WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE LOC ='DALLAS');
    -- SCOTT사원의 부서번호는 20번으로, 직급은 MANAGER로 한꺼번에 수정
SELELCT * FROM EMP WHERE ENAME = 'SCOTT'; 
    -- UPDATE EMP SET DEE
    -- 급여가 1500 이하인 직원의 급여인 1500 으로 수정(EM01
SELECT * FROM EMP01;
UPDATE EMP01 SET SAL = 1500 WHERE SAL<=1500;
    -- EX. 모든 사원의 급여와 입사일을 'KING' 의 급여와 입사일 수정
    UPDATE EMP01
        SET SAL = (SELECT SAL FROM EMP01 WHERE ENAME = 'KING',
        HIREDATE = (SELECT HIREDATE FROM EMP01 WHERE ENAME  = 'KING';

-- 1. EMP 테이블과 같은 구조와 같은 내용의 테이블 EMP01을 생성(테이블이 있을시 제거한후)하고, 모든 사원의 부서번호를 30번으로 수정합니다.

-- 2. EMP01테이블의 모든 사원의 급여를 10% 인상시키는 UPDATE문을 작성
SELECT * FROM EMP01;
UPDATE EMP01 SET SAL = SAL*1.1 WEHRE ENAME (SELECT * FROM EMP01);
-- 3. 급여가 3000이상인 사원만 급여를 10%인상
UPDATE EMP01 SET SAL = SAL*1.1WHERE SAL >=3000;
-- 4. EMP01테이블에서 ‘DALLAS’에서 근무하는 직원들의 연봉을 1000인상
UPDATE EMP01 SET SAL = SAL+1000
        WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE LOC ='DALLAS');
-- 5. SCOTT사원의 부서번호는 20번으로, 직급은 MANAGER로 한꺼번에 수정
SELELCT * FROM EMP WHERE ENAME = 'SCOTT'; 
-- 6. 부서명이 SALES인 사원을 모두 삭제하는 SQL작성
SELECT * FROM DEPT01;

-- 7. 사원명이 ‘FORD’인 사원을 삭제하는 SQL 작성
SELECT * FROM EMP01;
DELETE FROM EMP01 WHERE ENAME = 'FORD';
-- 8. SAM01 테이블에서 JOB이 NULL인 사원을 삭제하시오
SELECT * FROM  SAM01 WHERE JOB IS NULL;
DELETE FROM SAM01 WHERE JOB IS NULL;
-- 9. SAM01테이블에서 ENAME이 ORANGE인 사원을 삭제하시오
SELECT * FROM SAM01;
DELETE FROM SAM01 WHERE ENAME = 'ORANGE';
-- 10. 급여가 1500이하인 사람의 급여를 1500으로 수정
SELECT * FROM EMP01;
UPDATE EMP01 SET SAL =1500 WHERE SAL<=1500;
-- 11. JOB이 ‘MANAGER’인 사원의 급여를 10%인하하시    

    
 -- ※ 연습문제 ( CREATE, TABLE, DROP, TABLE, INSERT, UPDATE, DELETE, COMMIT)   
 ? SQL 활용 포트폴리오
--1. 아럐의 구조를 만족하는 MY_DATA 테이블을 생성하시오. 단 ID가 PRIMARY KEY이다.
DROP TABLE MY_DATA;
SELECT * FROM MY_DATA;
CREATE TABLE MY_DATA(
  ID        NUMBER(4) PRIMARY KEY,
  NAME     VARCHAR2(10),
  USERID    VARCHAR2(30),
  SALARY    NUMBER(10,2)     
);
-- 2. 생성된 테이블에 위의 도표와 같은 값을 입력하는 SQL문을 작성하시오.
INSERT INTO MY_DATA VALUES(1, 'SCOTT', 'sscott', 1000000);
INSERT INTO MY_DATA VALUES(2, 'FORD', 'fford', 1300000);
INSERT INTO MY_DATA VALUES(3, 'PATEL', 'ppatel', 3300000);
INSERT INTO MY_DATA VALUES(4, 'REPORT', 'rreport', 2350000);
INSERT INTO MY_DATA VALUES(5, 'GOOD', 'ggood', 4445000);

-- 3. TO_CHAR 내장 함수를 이용하여 입력한 자료를 위의 도표와 같은 형식으로 출력하는
--SQL문을 작성하시오
SELECT ID, INITCAP(NAME), USERID, TO_CHAR(SALARY, '99,999,999.99')  FROM MY_DATA;

-- 4. 자료를 영구적으로 데이터베이스에 등록하는 명령어를 작성하시오.
COMMIT;

-- 5. ID가 3번인 사람의 급여를 65000.00으로 갱신하고 영구적으로 데이터베이스에 반영하라.
UPDATE MY_DATA SET SALARY = 65000.00 WHERE ID = 3;

-- 6. NAME이 Ford인 사람을 삭제하고 영구적으로 데이터베이스에 반영하라.
DELETE FROM MY_DATA WHERE NAME = 'FORD';

-- 7. SALARY가 15,000.00 이하인 사람의 급여를 15,000.00으로 변경하라
UPDATE MY_DATA SET SALARY = 15000 WHERE SALARY <= 15000;

-- 8. 위에서 생성한 테이블을 삭제하라.   
DROP TABLE MY_DATA;   

-- ★ ★ ★ ★ 제약조건
-- (1) PRIMARY KEY : 테이블의 각 행을 유일한 값으로 식별하기 위한 필드
-- (2) FOREIGN KEY : 테이블의 열이 다른 테이블의 열을 참조
-- (3) NOT NULL : NULL을 포함하지 않음
-- (4) UNIQUE : 모든 행이 값이 유일. NULL 값은 허용(NULL은 여러개 가능)
-- (5) CHECK(조건) : 해당 조건이 만족(NULL값 허용)
-- DEFAULT 기본값 : 기본값설정(해당 열의 데이터를 입력하지 않으면 월래는 NULL이 들어갈 것을 DEFALUT값으로 입력)
SELECT *FROM DEPT01;
INSERT INTO DEPT01 (DEPTNO, DNAME) VALUES (99, 'XX');

-- DEPT1 테이블 생성
DROP TABLE DEPE1;
CREATE TABLE DEPT1 (
    DEPTNO NUMBER(2) PRIMARY KEY,
    DNAME VARCHAR2(14) NOT NULL UNIQUE,
    LOC VARCHAR2(13) NOT NULL
);
SELECT * FROM DEPT1;
SELECT * FROM USER_TABLES;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME='DEPT1';

-- EMP1 테이블 생성
CREATE TABLE EMP1 (
    EMPNO NUMBER(4) PRIMARY KEY,
    ENAME VARCHAR2(10) NOT NULL,
    JOB VARCHAR2(9) NOT NULL,
    MGR NUMBER(4),
    HIREDATE DATE DEFAULT SYSDATE,
    SAL NUMBER(7,2) CHECK(SAL>0),
    COMM NUMBER(7,2),
    DEPTNO NUMBER(2) REFERENCES DEPT1(DEPTNO)
);
SELECT * FROM EMP1;
 CREATE TABLE EMP1 (
    EMPNO NUMBER(4),
    ENAME VARCHAR2(10) NOT NULL,
    JOB VARCHAR2(9) NOT NULL,
    MGR NUMBER(4),
    HIREDATE DATE DEFAULT SYSDATE,
    SAL NUMBER(7,2),
    COMM NUMBER(7,2),
    PRIMARY KEY(EMPNO),
     CHECK(SAL>0),
     FOREIGN KEY(DEPTNO) REFERENCES DEPT1(DEPTNO)
);   
INSERT INTO EMP1 (EMPNO, ENAME, JOB) VALUES (1000, '홍길동','MANAGER');    
INSERT INTO EMP1 (EMPNO, ENAME, JOB, DEPTNO)
    VALUES (1001, '김길동', 'SALESMAN', 10); -- 에러
INSERT INTO DEPT1 SELECT * FROM DEPT; -- 10,20,30,40 입력
INSERT INTO DEPT1 VALUES (40, 'IT', 'SEOUL'); --에러
INSERT INTO DEPT1 VALUES (50, 'SALES', 'SEOUL'); --에러
INSERT INTO DEPT1 (DEPTNO ,DNAME) VALUES (50, 'IT'); --에러 (NOT NULL)
INSERT INTO DEPT1 VALUES (50, 'IT', 'SEOUL');

INSERT INTO EMP1 (EMPNO, ENAME, JOB, DEPTNO)
    VALUES (1001, '김길동', 'MANAGER', 60); -- 에러(FK)
INSERT INTO EMP1 (EMPNO, ENAME, JOB, SAL, DEPTNO)
    VALUES (1001, '김길동', 'MANAGER', 0, 50); -- 에러(CHECK)
INSERT INTO EMP1 (EMPNO, ENAME, JOB, SAL, DEPTNO)
    VALUES (1001, '김길동', 'MANAGER', 2000, 50); 
SELECT * FROM EMP1;
    
    -- BOOK -& BOOKCATEGORY
    
DROP TABLE BOOK;
DROP TABLE BOOKCATEGORY;
DROP TABLE BOOKCATEGORY CASCADE CONSTRAINTS; -- 참조하는 테이블 상관없이
CREATE TABLE BOOKCATEGORY (
    categoryCODE NUMBER(3) PRIMARY KEY,
    categoryNAME VARCHAR2(50) UNIQUE,
    OFFICE_LOC   VARCHAR2(50) NOT NULL
);
CREATE TABLE BOOK(
    BOOKNO VARCHAR2(10) PRIMARY KEY,
    CATEGORYCODE	NUMBER(3)	REFERENCES BOOKCATEGORY(categoryCODE),
    BOOKNAME VARCHAR2(50) NOT NULL,
    PUBLISHER VARCHAR2(50),
    PUBYEAR NUMBER(4) DEFAULT EXTRACT(YEAR FROM SYSDATE)
);
SELECT * FROM BOOKCATEGORY;
SELECT * FROM BOOK;
--
INSERT INTO BOOKCATEGORY VALUES (100, '철학', '3층인문실');
INSERT INTO BOOKCATEGORY VALUES (400, 'IT', '4층과학실');

INSERT INTO BOOK (BOOKNO, CATEGORYCODE, BOOKNAME, PUBLISHER) VALUES ('100A01', 100, '철학자의 삶', '이젠출판');
INSERT INTO BOOK VALUES ('400A01', 400, '이것이DB다', '다음출판',2022);
    
SELECT bookNo, bookNAME, PUBLISHER, PUBYEAR, categoryNAME, OFFICE_LOC
    FROM BOOK B, BOOKCATEGORY C
    WHERE B.categoryCODE = C.categoryCODE;
    
CREATE TABLE MAJOR(
    mCODE NUMBER(2) PRIMARY KEY,
    mNAME VARCHAR2(50) UNIQUE,
    mOFFICE VARCHAR2(255));
);   
CREATE TABLE STUDENT(
     SNO VARCHAR2(10) PRIMARY KEY,
    sNAME VARCHAR2(50) ,
    sSCORE NUMBER(3) CHECK (sSCORE BETWEEN 0 AND 100),
    mCODE NUMBER(2) REFERENCES MAJOR(mCODE) );
);
SELECT * FROM MAJOR;   
SELECT * FROM STUDENT;
DROP TABLE MAJOR;
DROP TABLE STUDENT;
INSERT INTO STUDENT VALUES ('101','홍길동', 99, 1);
INSERT INTO STUDENT VALUES ('102','신길동',100, 2);
INSERT INTO STUDENT VALUES ('103','신길동',-9, 3); -- CHECK 제약조건
INSERT INTO STUDENT VALUES (NULL,'신길동',90, 3);  -- PRIMARY KEY 제약조건=(NOT NULL+UNIQUE)
    
SELECT sNO, sNAME, SCORE, mCODE, mNAME, mOFFICE
    FROM MAJOR E, STUDENT S
    WHERE E.mCODE = S.mCODE;
    
    SELECT S.*, mNAME, mOFFICE
    FROM STUDENT S, MAJOR M 
    WHERE S.mCODE=M.mCODE;
    
-- ★  ★ ★ DCL : 계정생성 권한부여, 권한박탈, 계정삭제 ★  ★ ★  
-- 계정생성
create user scott2 IDENTIFIED BY tiger;  
-- 권한 부여 (세션권한 == 로그인 가능)
GRANT CREATE SESSION TO scott2;
GRANT CREATE TABLE TO scott2;
GRANT ALL ON EMP TO scott2;
GRANT SELECT ON DEPT TO SCOTT2;
-- 권한 박탈(DEPT, EMP)
REVOKE ALL ON EMP FROM SCOTT2;
REVOKE SELECT ON DEPT FROM SCOTT2;
    
-- 계정 삭제(SCOTT2) -- 접속해제
DROP USER SCOTT2 CASCADE;
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

